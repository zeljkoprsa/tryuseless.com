{"version":3,"sources":["../../src/server/patch-error-inspect.ts"],"sourcesContent":["import { findSourceMap, type SourceMapPayload } from 'module'\nimport type * as util from 'util'\nimport { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport { parseStack } from '../client/components/react-dev-overlay/server/middleware'\nimport { getOriginalCodeFrame } from '../client/components/react-dev-overlay/server/shared'\nimport { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'\n\ninterface ModernRawSourceMap extends SourceMapPayload {\n  ignoreList?: number[]\n}\n\ninterface IgnoreableStackFrame extends StackFrame {\n  ignored: boolean\n}\n\ntype SourceMapCache = Map<\n  string,\n  { map: SyncSourceMapConsumer; raw: ModernRawSourceMap }\n>\n\n// TODO: Implement for Edge runtime\nconst inspectSymbol = Symbol.for('nodejs.util.inspect.custom')\n\nfunction frameToString(frame: StackFrame): string {\n  let sourceLocation = frame.lineNumber !== null ? `:${frame.lineNumber}` : ''\n  if (frame.column !== null && sourceLocation !== '') {\n    sourceLocation += `:${frame.column}`\n  }\n  return frame.methodName\n    ? `    at ${frame.methodName} (${frame.file}${sourceLocation})`\n    : `    at ${frame.file}${frame.lineNumber}:${frame.column}`\n}\n\nfunction computeErrorName(error: Error): string {\n  // TODO: Node.js seems to use a different algorithm\n  // class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`\n  // in the stack i.e. seems like under certain conditions it favors the constructor name.\n  return error.name || 'Error'\n}\n\nfunction prepareUnsourcemappedStackTrace(\n  error: Error,\n  structuredStackTrace: any[]\n): string {\n  const name = computeErrorName(error)\n  const message = error.message || ''\n  let stack = name + ': ' + message\n  for (let i = 0; i < structuredStackTrace.length; i++) {\n    stack += '\\n    at ' + structuredStackTrace[i].toString()\n  }\n  return stack\n}\n\nfunction shouldIgnoreListByDefault(file: string): boolean {\n  return file.startsWith('node:')\n}\n\nfunction getSourcemappedFrameIfPossible(\n  frame: StackFrame,\n  sourceMapCache: SourceMapCache\n): {\n  stack: IgnoreableStackFrame\n  // DEV only\n  code: string | null\n} | null {\n  if (frame.file === null) {\n    return null\n  }\n\n  const sourceMapCacheEntry = sourceMapCache.get(frame.file)\n  let sourceMap: SyncSourceMapConsumer\n  let rawSourceMap: ModernRawSourceMap\n  if (sourceMapCacheEntry === undefined) {\n    const moduleSourceMap = findSourceMap(frame.file)\n    if (moduleSourceMap === undefined) {\n      return null\n    }\n    rawSourceMap = moduleSourceMap.payload\n    sourceMap = new SyncSourceMapConsumer(\n      // @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string\n      rawSourceMap\n    )\n    sourceMapCache.set(frame.file, {\n      map: sourceMap,\n      raw: rawSourceMap,\n    })\n  } else {\n    sourceMap = sourceMapCacheEntry.map\n    rawSourceMap = sourceMapCacheEntry.raw\n  }\n\n  const sourcePosition = sourceMap.originalPositionFor({\n    column: frame.column ?? 0,\n    line: frame.lineNumber ?? 1,\n  })\n\n  if (sourcePosition.source === null) {\n    return null\n  }\n\n  const sourceContent: string | null =\n    sourceMap.sourceContentFor(\n      sourcePosition.source,\n      /* returnNullOnMissing */ true\n    ) ?? null\n\n  // TODO: O(n^2). Consider moving `ignoreList` into a Set\n  const sourceIndex = rawSourceMap.sources.indexOf(sourcePosition.source)\n  const ignored = rawSourceMap.ignoreList?.includes(sourceIndex) ?? false\n\n  const originalFrame: IgnoreableStackFrame = {\n    methodName:\n      sourcePosition.name ||\n      // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n      // Resolve it back to `default` for the method name if the source position didn't have the method.\n      frame.methodName\n        ?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')\n        ?.replace('__webpack_exports__.', ''),\n    column: sourcePosition.column,\n    file: sourcePosition.source,\n    lineNumber: sourcePosition.line,\n    // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n    arguments: [],\n    ignored,\n  }\n\n  const codeFrame =\n    process.env.NODE_ENV !== 'production'\n      ? getOriginalCodeFrame(originalFrame, sourceContent)\n      : null\n\n  return {\n    stack: originalFrame,\n    code: codeFrame,\n  }\n}\n\nfunction parseAndSourceMap(error: Error): string {\n  // We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.\n  let unparsedStack = String(error.stack)\n  // We could just read it from `error.stack`.\n  // This works around cases where a 3rd party `Error.prepareStackTrace` implementation\n  // doesn't implement the name computation correctly.\n  const errorName = computeErrorName(error)\n\n  let idx = unparsedStack.indexOf('react-stack-bottom-frame')\n  if (idx !== -1) {\n    idx = unparsedStack.lastIndexOf('\\n', idx)\n  }\n  if (idx !== -1) {\n    // Cut off everything after the bottom frame since it'll be React internals.\n    unparsedStack = unparsedStack.slice(0, idx)\n  }\n\n  const unsourcemappedStack = parseStack(unparsedStack)\n  const sourceMapCache: SourceMapCache = new Map()\n\n  let sourceMappedStack = ''\n  let sourceFrameDEV: null | string = null\n  for (const frame of unsourcemappedStack) {\n    if (frame.file === null) {\n      sourceMappedStack += '\\n' + frameToString(frame)\n    } else if (!shouldIgnoreListByDefault(frame.file)) {\n      const sourcemappedFrame = getSourcemappedFrameIfPossible(\n        frame,\n        sourceMapCache\n      )\n\n      if (sourcemappedFrame === null) {\n        sourceMappedStack += '\\n' + frameToString(frame)\n      } else {\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          sourcemappedFrame.code !== null &&\n          sourceFrameDEV === null &&\n          // TODO: Is this the right choice?\n          !sourcemappedFrame.stack.ignored\n        ) {\n          sourceFrameDEV = sourcemappedFrame.code\n        }\n        if (!sourcemappedFrame.stack.ignored) {\n          // TODO: Consider what happens if every frame is ignore listed.\n          sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack)\n        }\n      }\n    }\n  }\n\n  return (\n    errorName +\n    ': ' +\n    error.message +\n    sourceMappedStack +\n    (sourceFrameDEV !== null ? '\\n' + sourceFrameDEV : '')\n  )\n}\n\nexport function patchErrorInspect() {\n  Error.prepareStackTrace = prepareUnsourcemappedStackTrace\n\n  // @ts-expect-error -- TODO upstream types\n  // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n  Error.prototype[inspectSymbol] = function (\n    depth: number,\n    inspectOptions: util.InspectOptions,\n    inspect: typeof util.inspect\n  ): string {\n    // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n    return workUnitAsyncStorage.exit(() => {\n      // Create a new Error object with the source mapping applied and then use native\n      // Node.js formatting on the result.\n      const newError =\n        this.cause !== undefined\n          ? // Setting an undefined `cause` would print `[cause]: undefined`\n            new Error(this.message, { cause: this.cause })\n          : new Error(this.message)\n\n      // TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name\n      newError.stack = parseAndSourceMap(this)\n\n      for (const key in this) {\n        if (!Object.prototype.hasOwnProperty.call(newError, key)) {\n          // @ts-expect-error -- We're copying all enumerable properties.\n          // So they definitely exist on `this` and obviously have no type on `newError` (yet)\n          newError[key] = this[key]\n        }\n      }\n\n      const originalCustomInspect = (newError as any)[inspectSymbol]\n      // Prevent infinite recursion.\n      // { customInspect: false } would result in `error.cause` not using our inspect.\n      Object.defineProperty(newError, inspectSymbol, {\n        value: undefined,\n        enumerable: false,\n        writable: true,\n      })\n      try {\n        return inspect(newError, {\n          ...inspectOptions,\n          depth:\n            (inspectOptions.depth ??\n              // Default in Node.js\n              2) - depth,\n        })\n      } finally {\n        ;(newError as any)[inspectSymbol] = originalCustomInspect\n      }\n    })\n  }\n}\n"],"names":["patchErrorInspect","inspectSymbol","Symbol","for","frameToString","frame","sourceLocation","lineNumber","column","methodName","file","computeErrorName","error","name","prepareUnsourcemappedStackTrace","structuredStackTrace","message","stack","i","length","toString","shouldIgnoreListByDefault","startsWith","getSourcemappedFrameIfPossible","sourceMapCache","rawSourceMap","sourceMapCacheEntry","get","sourceMap","undefined","moduleSourceMap","findSourceMap","payload","SyncSourceMapConsumer","set","map","raw","sourcePosition","originalPositionFor","line","source","sourceContent","sourceContentFor","sourceIndex","sources","indexOf","ignored","ignoreList","includes","originalFrame","replace","arguments","codeFrame","process","env","NODE_ENV","getOriginalCodeFrame","code","parseAndSourceMap","unparsedStack","String","errorName","idx","lastIndexOf","slice","unsourcemappedStack","parseStack","Map","sourceMappedStack","sourceFrameDEV","sourcemappedFrame","Error","prepareStackTrace","prototype","depth","inspectOptions","inspect","workUnitAsyncStorage","exit","newError","cause","key","Object","hasOwnProperty","call","originalCustomInspect","defineProperty","value","enumerable","writable"],"mappings":"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"}